<!DOCTYPE HTML>
<html lang="es">
  <head>
    <meta charset="utf-8">
    <title>La Guía del Punto Flotante - Comparación</title>
	
    <meta name="generator" content="nanoc 3.1.2">
	
		<meta name="Description" content="Explicación de los diversos problemas al comparar números de punto flotante">
	
    <link rel="stylesheet" type="text/css" href="/style.css" media="screen">
	<link rel="shortcut icon" href="/favicon.ico" type="image/vnd.microsoft.icon">
	<script type="text/javascript" src="https://apis.google.com/js/plusone.js"></script>
  </head>
  <body>  
    <div id="main">
		<h1>Comparación</h1>
      <p>Debido a los errores de redondeo, la mayoría de los números de <a href="/formats/fp/">punto flotante</a>
terminan siendo ligeramente imprecisos. Mientras esta imprecisión se mantenga pequeña,
normalmente se puede ignorar. Sin embargo, esto significa también que números que se
espera que sean iguales (por ejemplo al calcular el mismo resultado utilizando distintos
métodos correctos) a veces difieren levemente, y una simple prueba de igualdad falla.
Por ejemplo:</p>

<pre><code>	float a = 0.15 + 0.15
	float b = 0.1 + 0.2
	if(a == b) // ¡Puede ser falso!
	if(a &gt;= b) // ¡También puede ser falso!
</code></pre>

<h2 id="no-usar-mrgenes-de-error-absolutos">No usar márgenes de error absolutos</h2>

<p>La solución es comprobar no si los números son exactamente iguales, sino si su
diferencia es muy pequeña. El margen de error frente al que se compara esta diferencia
normalmente se llama <em>epsilon</em>. En su forma más simple:</p>

<pre><code>	if(Math.abs(a-b) &lt; 0.00001) // Mal - no hacer esto
</code></pre>

<p>Esto es una mala forma de hacerlo porque un epsilon fijo elegido porque «parece
pequeño» podría perfectamente ser demasiado grande cuando los números que se
comparan son también muy pequeños. La comparación devolvería «verdadero» para
números muy diferentes. Y cuando los números son muy grandes, el epsilon
puede acabar siendo más pequeño que el mínimo error de redondeo, por lo que
la comparación siempre devolvería «falso». Por tanto, es necesario ver si
el <em>error relativo</em> es menor epsilon:</p>

<pre><code>	if(Math.abs((a-b)/b) &lt; 0.00001) // ¡Todavía no es correcto!
</code></pre>

<h2 id="vigila-los-casos-lmite">Vigila los casos límite</h2>

<p>Hay algunos casos especiales importantes para los que esto falla:</p>

<ul>
  <li>Cuando tanto <code>a</code> como <code>b</code> son cero. <code>0.0/0.0</code> es NaN, lo que provoca una excepción en algunas plataformas o devuelve falso para todas las comparaciones.</li>
  <li>Cuando solo <code>b</code> es cero, la división devuelve infinito, lo que también puede causar una excepción, o es mayor que epsilon incluso cuando <code>a</code> es más pequeño.</li>
  <li>Devuelve «falso» cuando tanto <code>a</code> como <code>b</code> son muy pequeños pero a ambos lados del cero, incluso cuando son los números no nulos más pequeños.</li>
</ul>

<p>Además, el resultado no es conmutativo (<code>nearlyEquals(a,b)</code> no es siempre lo mismo que
<code>nearlyEquals(b,a)</code>). Para solucionar estos problemas, el código tiene que ser mucho más
complejo, así que necesitamos meterlo en una función:</p>

<pre><code>    public static boolean nearlyEqual(float a, float b, float epsilon)
    {
        final float absA = Math.abs(a);
        final float absB = Math.abs(b);
        final float diff = Math.abs(a - b);

        if (a == b) { // Atajo, maneja los infinitos
            return true;
        } else if (a * b == 0) { // a o b o ambos son cero
            // El error relativo no es importante aquí
            return diff &lt; (epsilon * epsilon);
        } else { // Usar el error relativo
            return diff / (absA + absB) &lt; epsilon;
        }
    }
</code></pre>

<p>Este método <a href="../NearlyEqualsTest.java">pasa las pruebas</a> para muchos casos especiales
importantes, pero como puedes ver, utiliza cierta lógica no trivial. En particular,
tiene que utilizar una definición totalmente distinta del margen de error cuando
<code>a</code> o <code>b</code> son cero, porque la definición clásica del error relativo es inútil en
esos casos.</p>

<p>Hay algunos casos en los que el método de arriba todavía produce resultados inesperados
(concretamente, es mucho más estricto cuando un valor es casi cero que cuando es
exactamente cero), y algunas de esas pruebas para las que fue desarrollado probablemente
especifica un comportamiento que no es apropiado para algunas aplicaciones. ¡Antes de
usarlo, asegúrate de que es adecuado para tu aplicación!</p>

<h2 id="comparando-valores-de-punto-flotante-como-enteros">Comparando valores de punto flotante como enteros</h2>

<p>Hay una alternativa a aplicar toda esta complejidad conceptual a una tarea aparentemente
tan sencilla: en lugar de comparar <code>a</code> y <code>b</code> como <a href="http://es.wikipedia.org/wiki/N%C3%BAmero_real">números
reales</a>, podemos concebirlos como pasos
discretos y definir el margen de error como el número máximo de valores de punto flotante
posibles entre esos dos números.</p>

<p>Esto es conceptualmente muy evidente y fácil y tiene la ventaja de que escala
implícitamente el margen de error relativo con la magnitud de los valores.
Técnicamente es un poco más complejo, pero no mucho más de lo que puedas pensar,
porque los números de punto flotante del IEEE 754 están diseñados para mantener su orden cuando
sus secuencias de bits se interpretan como enteros.</p>

<p>Sin embargo, este método requiere que el lenguaje de programación soporte conversión
entre valores de punto flotante y secuencias de bits enteras. Lee el artículo en
inglés <a href="/references/">Comparing floating-point numbers</a> para más detalles.</p>

			<g:plusone href="http://puntoflotante.org/"></g:plusone>
			<div id="license">
			<p>&copy; Publicado en <a href="http://puntoflotante.org/">http://puntoflotante.org/</a> bajo una licencia
			<a href="http://creativecommons.org/licenses/by/3.0/deed.es">Creative Commons Atribución Unported (BY)</a>.
			Original en inglés por Michael Borgwardt en
			<a href="http://floating-point-gui.de/">http://floating-point-gui.de/</a>.</p> 
		</div>
    </div>
    <div id="sidebar">
		<a href="/"><img src="/logo.png"></a>
		<h2>La Guía del Punto Flotante</h2>
		<ul>
            <li><a href="http://floating-point-gui.de/" alt="in English"><img src="/en.png"></a></li>
            <li><a href="/">Inicio</a></li>
			<li><a href="/basic/">Respuestas básicas</a></li>
			<li><a href="/references/">Referencias</a></li>
			<li><a href="/xkcd/">xkcd</a></li>
		</ul>
	  
		<h2>Formatos Numéricos</h2>
		<ul>
			<li><a href="/formats/binary/">Fracciones binarias</a></li>
			<li><a href="/formats/fp/">Punto flotante</a></li>
			<li><a href="/formats/exact/">Tipos exactos</a></li>
			<li><a href="/formats/integer/">Sobre usar enteros</a></li>
		</ul>
	
		<h2>Errores</h2>
		<ul>
			<li><a href="/errors/rounding/">Redondeo</a></li>
			<li><a href="/errors/comparison/">Comparación</a></li>
			<li><a href="/errors/propagation/">Propagación</a></li>
		</ul>
		
		<h2>Cheat sheets</h2>
		<ul>
			<li><a href="/languages/csharp/">C#</a></li>
			<li><a href="/languages/java/">Java</a></li>
			<li><a href="/languages/javascript/">JavaScript</a></li>
			<li><a href="/languages/perl/">Perl</a></li>
			<li><a href="/languages/php/">PHP</a></li>
			<li><a href="/languages/python/">Python</a></li>
			<li><a href="/languages/sql/">SQL</a></li>
		</ul>
    </div>
<a href="http://github.com/Pybonacci/puntoflotante.org"><img style="position: absolute; top: 0; right: 0; border: 0;" src="http://s3.amazonaws.com/github/ribbons/forkme_right_white_ffffff.png" alt="Fork me on GitHub" /></a>

  </body>
</html>
